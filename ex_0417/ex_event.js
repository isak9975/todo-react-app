//이벤트
//마우스 클릭, 오버, 더블클릭 등등
//키보드 입력

//이벤트를 처리하려고 하는 대상을 선택 
//document.getElementById(id값)
//id값을 가지고 있는 태그를 선택
//document.querySelector(선택자) 태크, 클래스, 아이디

//이벤트의 처리
//1. 속성에다 주기
//<Button onclick="함수호출">버튼</Button>

    //onclick : 눌렀을 때 작동
    //onchange : 입력값이 변경되고 포커스를 잃었을 때
    //onblur : 그냥 포커스를 잃었을대
    //oninput : 요소가 변경될 때

    //리액트에서는 카멜케이스로 쓴다.

    //html
    //<button onclick="handleClick()">클릭</button>

    //리액트
    //<button onClick={handleClick()}>클릭</button>

    let Button = () =>{
        function handleClick(event){

        return (
            <button onClick={handleClick()}>클릭</button>
        )
        }
        
    }

    //HTML + CSS,JS -> 매 페이지를 다 만들ㄷ어야함
    //REACT ->페이지 하나를 두고 요소만 바꿔끼우는 형태
    //SPA(Sing Page Applicaton) <-> MPA(Multi page Application)

    //브라우저가 화면을 렌더링 하는 방식
    //서버에 요청을 하고 화면을 돌려받는다.
    // 브라우저는 DOM크리를 만들고, CSSOM트리를 만든다
    //두개를 합쳐서 RENDER트리를 만들고 RENDER트리를 기반으로 브라우정체 요소들을 배치나다

    //렌더링 방식
    //클라이언트 사이드 렌더링(CSR)
    // ㄴ클라이언트 쪽에서 HTML,JS를 받아서 브라우저쪽에서 렌더링
    // ㄴ초기 로딩속도가 느림
    // ㄴ초기로딩 후, 필요한 데이터만 서버에서 가져와 동적으로 업데이트하기 
    //   때문에 추가 페이지 로딩이 없다.
    // ㄴ전체 페이지를 매번 새로 렌더링하지 않고, 변화가 있는 부분만 
    //   업데이트 하므로 서버에 부담을 덜어준다.
    //서버 사이드 렌더링(SSR) - React방식
    // ㄴ웹페이지를 렌더링을 시켜서 클라리언트한테 보낸다.
    // ㄴ초기 로딩이 빠르다.
    // ㄴ서버에 대한 부하가 커질 수 있다.

    //리액트란 뭘까?
    //페이스북에서 만든 라이브러리
    //SPA나 모바일 어플리케이션의 개발 토대로 사용이 된다.

    //컴포넌트 기반의 구조
    //-UI를 구성하는 독립적인 단위

    //컴포넌트의 특징
    //-UI조각
    //-HTML의 특정부분을 정의할 수 있다.
    //-버튼, 입력 필드, 다이얼로와 같은 다양한 UI 요소를 컴포넌트로
    //만들 수 있다.

    //재사용성
    //-컴포넌트는 재사용이 가능하다
    //-같은 코드를 여러번 쓰지 않아도 된다.

    //독립성
    //-컴포넌트는 독립적으로 동작할 수 있다.
    //-어플리케이션의 복잡한 UI를 작은 조각으로 나눠서 관리할 수 있다.

    //모든 컴포넌트는 함수로 관리한다.
    //컴포넌트 명은 첫글자를 대문자로 쓴다.
    // function 컴포넌트명(){
    //     return(HTML코드)
    // }


    //JSX(JavaScript XML)
    //자바스크립트 안에 HTML처럼 UI구조를 작성할 수 있게 해주는 문법
    //const element = <div className="container">Hello</div>

    //표현식의 삽입
    //중괄호 { }안에 임의의 JS표현식을 넣어 결과를 렌더링할 수 있다.
    // const name = '홍길동';
    // const element = <h1>안녕, {name}님</h1>

    //배열에 있는 내용을 꺼내서 화면에 렌더링을 해야함


    //Hook
    //리액트에서 제공하는 메서드
    //리액트 초반 함수형 컴포넌트는 단순한 UI그리기만 가능하고
    //상태에 대한 관리를 할 수 없었다.

    //훅의 역활
    //상태 관리와 사이드 이펙트 로직을 함수 단위로 재사용할 수 있게 하고, 
    //클래스 없이도 복잡한 로직을 깔끔하게 작성하도록 돕는다.

    //상태(state)
    //컴포넌트 내부에서 변경 가능한 데이터
    //state가 바뀌면 해당 컴포넌트가 다시 렌더링 되어
    //화면에 변경된 내용을 반영한다.

    //state를 생성하는 법
    //useState()라는 훅을 사용해야 한다.
    //컴포넌트 내부에서 state를 선언하고 변경할 때 사용하는 훅

    //useState()훅이 실행이 되면 state 하나와 state의 값을 변경할 수 
    //있는 setter함수가 요소로 있는 배열을 반환 

    //리액트는 변수를 이렇게 만든다.
    //초기값 자리에 기본자료형, 배열, 객체도 된다.
    //const[상태변수,setter함수] = useState(초기값);
    // ㄴ setter 함수를 이용해서 state를 변경하면 화면에 바로 반영.
    // ㄴ 일반 자바스크립트 지역변수는 값이 바뀌어도 화면에 렌더링이 일어나지 않는다.
    
    //왜 useState()가 제공하는 setter 함수를 실행했을 때 자동으로 화면이 렌더링 되는가
    //1. setter함수를 호출하면 상태가 바뀌었다는 사실을 React에 알린다.
    //  이 컴포넌트를 재 렌더링해야한다고 예약한다.
    //  예약된 업데이트 시점에 React는 해당 컴포넌트를 다시 호출해 JSX를 살펴본다.
    //  이전 렌더 때와 달리 바뀐값을 반환하므로 JSX의 결과가 달라질 수 있다.

    //Props
    //컴포넌트에 데이터를 전달하는 방식
    //외부로부터 값을 받아서 렌더링하거나 동작할 수 있다.
    //prop라는 이름의 자바스크립트 객체이다.
    
    //기본적으로 props로 넘오언 데이터들은 읽기 전용이지만
    //수정하고 싶다면 state를 이용해서 바꾸면 된다.



    //리액트에서 매개변수 -> props
    //리액트에서 생명주기를 관리하는 변수 -> state

    //생명주기 -> 언제 메모리 올라가서 언제 없어지는가